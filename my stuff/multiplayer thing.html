<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multiplayer Chat & Canvas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: #0a0a0a;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: #1a1a1a;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tabs {
            display: flex;
            background: #222;
            border-bottom: 1px solid #333;
        }

        .tab {
            flex: 1;
            padding: 1rem;
            background: #333;
            border: none;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s;
        }

        .tab.active {
            background: #555;
        }

        .tab:hover {
            background: #444;
        }

        /* Chat Styles */
        .chat-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
            border: 1px solid #333;
            background: #111;
            margin-bottom: 1rem;
        }

        .message {
            padding: 0.5rem 1rem;
            margin: 0.25rem 0;
            border-radius: 4px;
            background: #222;
            word-wrap: break-word;
        }

        .message-input {
            display: flex;
            gap: 0.5rem;
        }

        .message-input input {
            flex: 1;
            padding: 0.75rem;
            background: #222;
            border: 1px solid #333;
            color: #fff;
            border-radius: 4px;
            outline: none;
        }

        .message-input button {
            padding: 0.75rem 1.5rem;
            background: #007acc;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Canvas Styles */
        .canvas-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .canvas-toolbar {
            display: flex;
            gap: 0.5rem;
            padding: 1rem;
            background: #222;
            border-bottom: 1px solid #333;
            flex-wrap: wrap;
            align-items: center;
        }

        .canvas-toolbar button, .canvas-toolbar input {
            padding: 0.5rem;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .canvas-toolbar button:hover {
            background: #444;
        }

        .canvas-toolbar button.active {
            background: #007acc;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fff;
        }

        .canvas-area {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background: #fff;
        }

        .transform-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #007acc;
            border: 1px solid #fff;
            cursor: pointer;
            z-index: 10;
        }

        .transform-handle.corner { cursor: nw-resize; }
        .transform-handle.rotate { 
            border-radius: 50%;
            background: #ff6b6b;
            cursor: grab;
        }

        /* Room Styles */
        .room-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .room-controls {
            padding: 1rem;
            border-bottom: 1px solid #333;
        }

        .room-controls input, .room-controls button {
            width: 100%;
            margin: 0.25rem 0;
            padding: 0.75rem;
            background: #222;
            border: 1px solid #333;
            color: #fff;
            border-radius: 4px;
        }

        .room-controls button {
            background: #007acc;
            cursor: pointer;
        }

        .room-item {
            padding: 1rem;
            margin: 0.5rem 0;
            background: #222;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .room-item:hover {
            background: #333;
        }

        .room-item.active {
            background: #007acc;
        }

        .room-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .room-name {
            font-weight: bold;
        }

        .room-users {
            font-size: 0.8em;
            color: #aaa;
        }

        .room-privacy {
            font-size: 0.7em;
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            background: #333;
        }

        .room-privacy.private {
            background: #ff6b6b;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 40%;
                border-right: none;
                border-bottom: 1px solid #333;
            }
            
            .canvas-toolbar {
                padding: 0.5rem;
                gap: 0.25rem;
            }
            
            .canvas-toolbar button, .canvas-toolbar input {
                padding: 0.3rem;
                font-size: 10px;
            }
        }

        .hidden {
            display: none !important;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            color: #666;
        }

        /* Input file styling */
        .file-input {
            display: none;
        }

        /* Color picker styling */
        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Brush size slider */
        input[type="range"] {
            width: 80px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="room-controls">
                <input type="text" id="roomNameInput" placeholder="Room name...">
                <label>
                    <input type="checkbox" id="privateRoomCheck"> Private Room
                </label>
                <button id="createRoomBtn">Create Room</button>
                <button id="joinRoomBtn" disabled>Join Selected Room</button>
            </div>
            <div class="room-list" id="roomList">
                <div class="loading">Loading rooms...</div>
            </div>
        </div>

        <div class="main-content">
            <div class="tabs">
                <button class="tab active" data-tab="chat">Chat</button>
                <button class="tab" data-tab="canvas">Canvas</button>
            </div>

            <div id="chatTab" class="chat-section">
                <div class="chat-messages" id="chatMessages"></div>
                <div class="message-input">
                    <input type="text" id="messageInput" placeholder="Type a message...">
                    <button id="sendMessageBtn">Send</button>
                </div>
            </div>

            <div id="canvasTab" class="canvas-section hidden">
                <div class="canvas-toolbar">
                    <button id="brushTool" class="active">Brush</button>
                    <button id="eraserTool">Eraser</button>
                    <button id="fillTool">Fill</button>
                    <input type="color" id="colorPicker" value="#000000">
                    <input type="range" id="brushSize" min="1" max="50" value="5">
                    <span>Size: <span id="brushSizeDisplay">5</span>px</span>
                    <button id="undoBtn">Undo</button>
                    <button id="redoBtn">Redo</button>
                    <button id="clearBtn">Clear</button>
                    <button id="importBtn">Import</button>
                    <input type="file" id="fileInput" class="file-input" accept="image/*">
                    <button id="downloadBtn">Download</button>
                </div>
                <div class="canvas-container">
                    <div class="canvas-area">
                        <canvas id="drawingCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script>
        class MultiplayerApp {
            constructor() {
                this.gun = Gun();
                this.userId = 'user_' + Math.random().toString(36).substr(2, 9);
                this.currentRoom = null;
                this.selectedRoom = null;
                this.messageHistory = new Set();
                
                this.initUI();
                this.initCanvas();
                this.loadRooms();
                this.startHeartbeat();
            }

            initUI() {
                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const tabName = e.target.dataset.tab;
                        this.switchTab(tabName);
                    });
                });

                // Room controls
                document.getElementById('createRoomBtn').addEventListener('click', () => this.createRoom());
                document.getElementById('joinRoomBtn').addEventListener('click', () => this.joinRoom());
                
                // Chat
                document.getElementById('sendMessageBtn').addEventListener('click', () => this.sendMessage());
                document.getElementById('messageInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMessage();
                });

                // Canvas toolbar
                this.setupCanvasToolbar();
            }

            switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                
                document.querySelectorAll('.chat-section, .canvas-section').forEach(s => s.classList.add('hidden'));
                document.getElementById(tabName + 'Tab').classList.remove('hidden');

                if (tabName === 'canvas') {
                    this.resizeCanvas();
                }
            }

            createRoom() {
                const roomName = document.getElementById('roomNameInput').value.trim();
                if (!roomName) return;

                const isPrivate = document.getElementById('privateRoomCheck').checked;
                const roomId = 'room_' + Math.random().toString(36).substr(2, 9);
                
                const roomData = {
                    id: roomId,
                    name: roomName,
                    host: this.userId,
                    private: isPrivate,
                    users: [this.userId],
                    created: Date.now(),
                    lastActivity: Date.now()
                };

                this.gun.get('rooms').get(roomId).put(roomData);
                document.getElementById('roomNameInput').value = '';
                document.getElementById('privateRoomCheck').checked = false;
                
                setTimeout(() => this.joinRoomById(roomId), 500);
            }

            joinRoom() {
                if (this.selectedRoom) {
                    this.joinRoomById(this.selectedRoom);
                }
            }

            joinRoomById(roomId) {
                if (this.currentRoom) {
                    this.leaveCurrentRoom();
                }

                this.currentRoom = roomId;
                this.gun.get('rooms').get(roomId).get('users').set(this.userId);
                this.gun.get('rooms').get(roomId).put({ lastActivity: Date.now() });
                
                this.loadRoomMessages();
                this.loadCanvasData();
                this.updateRoomUserCount();
            }

            leaveCurrentRoom() {
                if (this.currentRoom) {
                    this.gun.get('rooms').get(this.currentRoom).get('users').get(this.userId).put(null);
                    this.currentRoom = null;
                    document.getElementById('chatMessages').innerHTML = '';
                    this.clearCanvas();
                }
            }

            loadRooms() {
                this.gun.get('rooms').map().on((roomData, roomId) => {
                    if (roomData && roomData.name) {
                        this.updateRoomInList(roomId, roomData);
                        this.cleanupEmptyRooms(roomId, roomData);
                    }
                });
            }

            updateRoomInList(roomId, roomData) {
                const roomList = document.getElementById('roomList');
                let roomElement = document.getElementById('room_' + roomId);
                
                if (!roomElement) {
                    roomElement = document.createElement('div');
                    roomElement.id = 'room_' + roomId;
                    roomElement.className = 'room-item';
                    roomList.appendChild(roomElement);
                    
                    roomElement.addEventListener('click', () => {
                        document.querySelectorAll('.room-item').forEach(r => r.classList.remove('active'));
                        roomElement.classList.add('active');
                        this.selectedRoom = roomId;
                        document.getElementById('joinRoomBtn').disabled = false;
                    });
                }

                // Count active users
                let userCount = 0;
                if (roomData.users) {
                    this.gun.get('rooms').get(roomId).get('users').map().once((user, userId) => {
                        if (user) userCount++;
                    });
                }

                roomElement.innerHTML = `
                    <div class="room-info">
                        <div class="room-name">${roomData.name}</div>
                        <div class="room-privacy ${roomData.private ? 'private' : ''}">${roomData.private ? 'Private' : 'Public'}</div>
                    </div>
                    <div class="room-users">${userCount} users online</div>
                `;
            }

            cleanupEmptyRooms(roomId, roomData) {
                setTimeout(() => {
                    let hasUsers = false;
                    this.gun.get('rooms').get(roomId).get('users').map().once((user, userId) => {
                        if (user) hasUsers = true;
                    });
                    
                    if (!hasUsers && Date.now() - roomData.lastActivity > 60000) {
                        this.gun.get('rooms').get(roomId).put(null);
                        const roomElement = document.getElementById('room_' + roomId);
                        if (roomElement) roomElement.remove();
                    }
                }, 30000);
            }

            loadRoomMessages() {
                if (!this.currentRoom) return;
                
                this.gun.get('rooms').get(this.currentRoom).get('messages').map().on((messageData, messageId) => {
                    if (messageData && !this.messageHistory.has(messageId)) {
                        this.displayMessage(messageData);
                        this.messageHistory.add(messageId);
                    }
                });
            }

            sendMessage() {
                const input = document.getElementById('messageInput');
                const text = input.value.trim();
                if (!text || !this.currentRoom) return;

                const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const messageData = {
                    id: messageId,
                    user: this.userId,
                    text: text,
                    timestamp: Date.now()
                };

                this.gun.get('rooms').get(this.currentRoom).get('messages').get(messageId).put(messageData);
                input.value = '';
            }

            displayMessage(messageData) {
                const messagesContainer = document.getElementById('chatMessages');
                const messageElement = document.createElement('div');
                messageElement.className = 'message';
                messageElement.textContent = `${messageData.user}: ${messageData.text}`;
                messagesContainer.appendChild(messageElement);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            // Canvas Implementation
            initCanvas() {
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.isDrawing = false;
                this.currentTool = 'brush';
                this.brushSize = 5;
                this.currentColor = '#000000';
                this.undoStack = [];
                this.redoStack = [];
                this.lastPoint = null;
                this.images = [];
                this.selectedImage = null;
                
                this.resizeCanvas();
                this.setupCanvasEvents();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const container = document.querySelector('.canvas-container');
                if (!container) return;
                
                const rect = container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.redrawCanvas();
            }

            setupCanvasToolbar() {
                document.getElementById('brushTool').addEventListener('click', () => this.setTool('brush'));
                document.getElementById('eraserTool').addEventListener('click', () => this.setTool('eraser'));
                document.getElementById('fillTool').addEventListener('click', () => this.setTool('fill'));
                document.getElementById('colorPicker').addEventListener('change', (e) => this.currentColor = e.target.value);
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.brushSize = e.target.value;
                    document.getElementById('brushSizeDisplay').textContent = e.target.value;
                });
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas());
                document.getElementById('importBtn').addEventListener('click', () => document.getElementById('fileInput').click());
                document.getElementById('fileInput').addEventListener('change', (e) => this.importImage(e));
                document.getElementById('downloadBtn').addEventListener('click', () => this.downloadCanvas());
            }

            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('.canvas-toolbar button').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                this.canvas.style.cursor = tool === 'brush' ? 'crosshair' : 
                                          tool === 'eraser' ? 'grab' : 
                                          'crosshair';
            }

            setupCanvasEvents() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseout', () => this.stopDrawing());

                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const mouseEvent = new MouseEvent('mouseup', {});
                    this.canvas.dispatchEvent(mouseEvent);
                });
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            startDrawing(e) {
                this.isDrawing = true;
                const pos = this.getMousePos(e);
                this.lastPoint = pos;
                
                if (this.currentTool === 'fill') {
                    this.floodFill(pos.x, pos.y, this.currentColor);
                    this.saveState();
                    this.syncCanvas();
                }
            }

            draw(e) {
                if (!this.isDrawing || this.currentTool === 'fill') return;
                
                const pos = this.getMousePos(e);
                
                this.ctx.globalCompositeOperation = this.currentTool === 'eraser' ? 'destination-out' : 'source-over';
                this.ctx.strokeStyle = this.currentColor;
                this.ctx.lineWidth = this.brushSize;
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.lastPoint.x, this.lastPoint.y);
                this.ctx.lineTo(pos.x, pos.y);
                this.ctx.stroke();
                
                this.lastPoint = pos;
                
                // Sync drawing data
                const drawData = {
                    tool: this.currentTool,
                    color: this.currentColor,
                    size: this.brushSize,
                    from: this.lastPoint,
                    to: pos,
                    timestamp: Date.now()
                };
                
                if (this.currentRoom) {
                    this.gun.get('rooms').get(this.currentRoom).get('canvas').get('strokes').set(drawData);
                }
            }

            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.saveState();
                }
            }

            floodFill(startX, startY, fillColor) {
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;
                const stack = [[Math.floor(startX), Math.floor(startY)]];
                const fillColorRgb = this.hexToRgb(fillColor);
                const targetColor = this.getPixelColor(data, startX, startY, this.canvas.width);
                
                if (this.colorsMatch(targetColor, fillColorRgb)) return;
                
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    if (x < 0 || x >= this.canvas.width || y < 0 || y >= this.canvas.height) continue;
                    
                    const currentColor = this.getPixelColor(data, x, y, this.canvas.width);
                    if (!this.colorsMatch(currentColor, targetColor)) continue;
                    
                    this.setPixelColor(data, x, y, this.canvas.width, fillColorRgb);
                    
                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            getPixelColor(data, x, y, width) {
                const index = (y * width + x) * 4;
                return {
                    r: data[index],
                    g: data[index + 1],
                    b: data[index + 2]
                };
            }

            setPixelColor(data, x, y, width, color) {
                const index = (y * width + x) * 4;
                data[index] = color.r;
                data[index + 1] = color.g;
                data[index + 2] = color.b;
                data[index + 3] = 255;
            }

            colorsMatch(color1, color2) {
                return color1.r === color2.r && color1.g === color2.g && color1.b === color2.b;
            }

            saveState() {
                this.undoStack.push(this.canvas.toDataURL());
                if (this.undoStack.length > 50) this.undoStack.shift();
                this.redoStack = [];
            }

            undo() {
                if (this.undoStack.length > 0) {
                    this.redoStack.push(this.canvas.toDataURL());
                    const previousState = this.undoStack.pop();
                    this.loadCanvasFromDataURL(previousState);
                    this.syncCanvas();
                }
            }

            redo() {
                if (this.redoStack.length > 0) {
                    this.undoStack.push(this.canvas.toDataURL());
                    const nextState = this.redoStack.pop();
                    this.loadCanvasFromDataURL(nextState);
                    this.syncCanvas();
                }
            }

            loadCanvasFromDataURL(dataURL) {
                const img = new Image();
                img.onload = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.drawImage(img, 0, 0);
                };
                img.src = dataURL;
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.saveState();
                this.syncCanvas();
            }

            importImage(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        this.ctx.drawImage(img, 0, 0, img.width, img.height);
                        this.saveState();
                        this.syncCanvas();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }

            downloadCanvas() {
                const link = document.createElement('a');
                link.download = 'canvas-drawing.png';
                link.href = this.canvas.toDataURL();
                link.click();
            }

            syncCanvas() {
                if (this.currentRoom) {
                    const canvasData = this.canvas.toDataURL();
                    this.gun.get('rooms').get(this.currentRoom).get('canvas').put({
                        data: canvasData,
                        timestamp: Date.now()
                    });
                }
            }

            loadCanvasData() {
                if (!this.currentRoom) return;
                
                this.gun.get('rooms').get(this.currentRoom).get('canvas').on((canvasData) => {
                    if (canvasData && canvasData.data) {
                        this.loadCanvasFromDataURL(canvasData.data);
                    }
                });
            }

            redrawCanvas() {
                // Redraw any persistent canvas elements
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            updateRoomUserCount() {
                if (!this.currentRoom) return;
                
                setInterval(() => {
                    this.gun.get('rooms').get(this.currentRoom).put({ lastActivity: Date.now() });
                }, 30000);
            }

            startHeartbeat() {
                setInterval(() => {
                    if (this.currentRoom) {
                        this.gun.get('rooms').get(this.currentRoom).get('users').get(this.userId).put({
                            id: this.userId,
                            lastSeen: Date.now()
                        });
                    }
                }, 15000);
            }
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            new MultiplayerApp();
        });

        // Prevent context menu on mobile
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // Prevent zoom on double tap
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>
