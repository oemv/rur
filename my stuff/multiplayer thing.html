<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Canvas - Firebase Debug</title>
    
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --black: #000000;
            --white: #FFFFFF;
            --border-color: var(--white);
            --text-color: var(--white);
            --bg-color: var(--black);
            --interactive-bg: var(--white);
            --interactive-text: var(--black);
            --interactive-border: var(--white);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
            touch-action: none; 
        }

        .app-container { display: flex; height: 100vh; }
        .sidebar {
            width: 280px; background: var(--bg-color);
            border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .main-content {
            flex: 1; display: flex; flex-direction: column;
            overflow: hidden; background: var(--bg-color);
        }
        .header {
            padding: 15px 20px; border-bottom: 1px solid var(--border-color);
            display: flex; align-items: center;
        }
        .header h1, .header h2 { font-size: 18px; font-weight: 600; color: var(--text-color); }
        .mobile-menu-btn { 
            display: none; background: transparent; color: var(--white);
            border: 1px solid var(--white); padding: 8px; border-radius: 4px;
            cursor: pointer; margin-right: 10px; z-index: 101;
        }
        .mobile-menu-btn:hover { background: var(--white); color: var(--black); }
        .section { padding: 20px; border-bottom: 1px solid var(--border-color); }
        .section:last-child { border-bottom: none; }
        .room-list-section { flex: 1; display: flex; flex-direction: column; }
        .section h3 {
            font-size: 14px; font-weight: 500; color: var(--text-color);
            margin-bottom: 15px; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .form-group { display: flex; flex-direction: column; gap: 10px; margin-bottom:15px; }
        .form-group input[type="text"], .form-group input[type="password"] {
            padding: 10px 12px; border: 1px solid var(--border-color); border-radius: 4px;
            font-size: 14px; background: var(--bg-color); color: var(--text-color);
        }
        .form-group input[type="text"]::placeholder, .form-group input[type="password"]::placeholder {
            color: rgba(255,255,255,0.5);
        }
        .form-group label { display: flex; align-items: center; font-size: 14px; color: var(--text-color); }
        .form-group input[type="checkbox"] { margin-right: 8px; accent-color: var(--white); }
        button.primary-btn, button.secondary-btn {
            padding: 10px 12px; border-radius: 4px; font-size: 14px; font-weight: 500;
            cursor: pointer; transition: background 0.2s, color 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        button.primary-btn {
            background: var(--interactive-bg); color: var(--interactive-text);
            border: 1px solid var(--interactive-border);
        }
        button.primary-btn:hover { background: var(--bg-color); color: var(--text-color); }
        button.secondary-btn {
            background: var(--bg-color); color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        button.secondary-btn:hover { background: var(--interactive-bg); color: var(--interactive-text); }
        .room-list { flex: 1; overflow-y: auto; padding: 0 0 20px 0; }
        .room-item {
            padding: 12px; margin-bottom: 8px; background: var(--bg-color);
            border: 1px solid var(--border-color); border-radius: 4px;
            cursor: pointer; transition: all 0.2s;
        }
        .room-item:hover { border-color: var(--white); background: rgba(255,255,255,0.1); }
        .room-item.active {
            background: var(--interactive-bg); color: var(--interactive-text);
            border-color: var(--interactive-bg);
        }
        .room-item.active .room-name, .room-item.active .room-info { color: var(--interactive-text); }
        .room-name { font-weight: 600; font-size: 14px; color: var(--text-color); }
        .room-info { font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 4px; }
        .canvas-container {
            flex: 1; position: relative; overflow: hidden;
            border-bottom: 1px solid var(--border-color);
        }
        .canvas-wrapper {
            position: absolute; top: 0; left: 0; right: 0; bottom: 60px; 
            overflow: hidden; background: var(--white); 
        }
        #canvas { display: block; cursor: crosshair; background: var(--white); }
        .toolbar {
            position: absolute; bottom: 0; left: 0; right: 0; height: 60px;
            background: var(--bg-color); display: flex; align-items: center;
            padding: 0 10px; gap: 5px; overflow-x: auto;
        }
        .tool-btn {
            padding: 8px; background: var(--bg-color); color: var(--text-color);
            border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer;
            min-width: 40px; height: 40px; display: flex; align-items: center;
            justify-content: center; transition: all 0.2s;
        }
        .tool-btn svg { width: 20px; height: 20px; }
        .tool-btn:hover { background: var(--interactive-bg); color: var(--interactive-text); }
        .tool-btn.active { background: var(--interactive-bg); color: var(--interactive-text); border-color: var(--interactive-bg); }
        .tool-btn:disabled {
            opacity: 0.5; cursor: not-allowed; background: var(--bg-color);
            color: var(--text-color); border-color: var(--border-color);
        }
        input[type="color"], input[type="range"] { margin: 0 5px; }
        input[type="color"] {
            width: 36px; height: 36px; border: 1px solid var(--border-color);
            padding: 2px; background: var(--bg-color); border-radius: 4px;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 2px; }
        .size-slider { width: 100px; accent-color: var(--white); }
        .chat-section { height: 250px; display: flex; flex-direction: column; background: var(--bg-color); }
        .users-list {
            padding: 10px 15px; border-bottom: 1px solid var(--border-color);
            background: var(--bg-color); flex-shrink: 0;
            white-space: nowrap; overflow-x: auto;
        }
        .user-item {
            display: inline-block; padding: 4px 10px; margin: 2px;
            background: var(--bg-color); color: var(--text-color);
            border: 1px solid var(--border-color); border-radius: 15px; font-size: 12px;
        }
        .user-item.me { background: var(--white); color: var(--black); border-color: var(--white); }
        .chat-messages { flex: 1; overflow-y: auto; padding: 15px; }
        .message {
            margin-bottom: 10px; padding: 8px 12px; background: var(--bg-color);
            border: 1px solid var(--border-color); border-radius: 6px;
            font-size: 14px; max-width: 85%;
        }
        .message.own-message {
            margin-left: auto; background: var(--interactive-bg);
            color: var(--interactive-text); border-color: var(--interactive-bg);
        }
        .message.own-message .message-author{ color: var(--interactive-text); }
        .message-author { font-weight: 600; color: var(--text-color); display: block; margin-bottom: 3px; }
        .message-text { word-wrap: break-word; }
        .chat-input-area { display: flex; padding: 15px; gap: 10px; border-top: 1px solid var(--border-color); }
        .chat-input-area input[type="text"] {
            flex: 1; padding: 10px 12px; border: 1px solid var(--border-color);
            border-radius: 4px; font-size: 14px; background: var(--bg-color); color: var(--text-color);
        }
        .chat-input-area input[type="text"]::placeholder { color: rgba(255,255,255,0.5); }
        .chat-input-area button {
            padding: 10px; background: var(--interactive-bg); color: var(--interactive-text);
            border: 1px solid var(--interactive-border); border-radius: 4px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            width: 44px; height: 44px;
        }
        .chat-input-area button svg { width: 20px; height: 20px; }
        .chat-input-area button:hover { background: var(--bg-color); color: var(--text-color); }
        .modal {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85); display: flex;
            align-items: center; justify-content: center;
            z-index: 1000; padding: 20px;
        }
        .modal-content {
            background: var(--bg-color); padding: 25px; border-radius: 6px;
            border: 1px solid var(--border-color); max-width: 400px; width: 100%;
        }
        .modal-content h3 { font-size: 18px; margin-bottom: 20px; color: var(--text-color); }
        .modal-content .form-group { margin-bottom: 20px; }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
        .hidden { display: none !important; }
        @media (max-width: 768px) {
            .sidebar {
                width: 100%; position: absolute; z-index: 100;
                left: -100%; transition: left 0.3s ease-in-out; border-right: none; 
            }
            .sidebar.open { left: 0; }
            .main-content { margin-left:0; }
            .mobile-menu-btn { display: flex; position: absolute; top: 12px; left: 15px; }
            .header h1, .header h2 { margin-left: 45px; } 
        }
        .selection-handles { position: absolute; pointer-events: none; }
        .handle {
            position: absolute; width: 8px; height: 8px; background: var(--white);
            border: 1px solid var(--black); border-radius: 50%;
            pointer-events: all; cursor: pointer;
        }
        .handle.rotate { background: var(--white); border-radius: 0; transform: rotate(45deg); }
    </style>
</head>
<body>
    <div class="app-container" id="appContainer">
        <div class="sidebar" id="sidebar">
            <div class="header">
                <button class="mobile-menu-btn" onclick="window.toggleSidebar()">
                    <i data-lucide="x"></i>
                </button>
                <h1>Canvas Rooms</h1>
            </div>
            
            <div class="section">
                <h3>Create Room</h3>
                <div class="form-group">
                    <input type="text" id="roomNameInput" placeholder="Room name">
                    <input type="text" id="usernameInput" placeholder="Your username">
                    <label>
                        <input type="checkbox" id="isPrivateCheckbox"> Private room
                    </label>
                </div>
                <button class="primary-btn" onclick="window.createRoom()">
                    <i data-lucide="plus-circle"></i> Create Room
                </button>
            </div>
            
            <div class="section room-list-section">
                <h3>Active Rooms</h3>
                <div class="room-list" id="roomList">
                    <!-- Rooms will be populated by JS -->
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="header main-header">
                 <button class="mobile-menu-btn" id="mainMobileMenuBtn" onclick="window.toggleSidebar()">
                    <i data-lucide="menu"></i>
                </button>
                <h2 id="currentRoomTitle">Canvas Area</h2>
            </div>

            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="canvas" width="1200" height="800"></canvas>
                    <div class="selection-handles hidden" id="selectionHandles"></div>
                </div>
                
                <div class="toolbar">
                    <button class="tool-btn active" data-tool="brush" title="Brush"><i data-lucide="paint-brush"></i></button>
                    <button class="tool-btn" data-tool="eraser" title="Eraser"><i data-lucide="eraser"></i></button>
                    <button class="tool-btn" data-tool="fill" title="Fill Bucket"><i data-lucide="paint-bucket"></i></button>
                    <button class="tool-btn" data-tool="select" title="Select"><i data-lucide="mouse-pointer-click"></i></button>
                    <input type="color" id="colorPicker" value="#000000" title="Color Picker">
                    <input type="range" id="brushSize" class="size-slider" min="1" max="50" value="5" title="Brush Size">
                    <button class="tool-btn" onclick="window.undo()" title="Undo" disabled><i data-lucide="undo-2"></i></button>
                    <button class="tool-btn" onclick="window.redo()" title="Redo" disabled><i data-lucide="redo-2"></i></button>
                    <button class="tool-btn" onclick="window.clearCanvas()" title="Clear Canvas"><i data-lucide="trash-2"></i></button>
                    <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                    <button class="tool-btn" onclick="document.getElementById('imageUpload').click();" title="Import Image"><i data-lucide="image-plus"></i></button>
                    <button class="tool-btn" onclick="window.downloadCanvas()" title="Download Image"><i data-lucide="download"></i></button>
                </div>
            </div>
            
            <div class="chat-section">
                <div class="users-list" id="usersList">
                </div>
                <div class="chat-messages" id="chatMessages">
                </div>
                <div class="chat-input-area">
                    <input type="text" id="messageInput" placeholder="Type a message...">
                    <button onclick="window.sendMessage()" title="Send Message">
                        <i data-lucide="send"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal hidden" id="joinModal">
        <div class="modal-content">
            <h3 id="joinModalTitle">Join Room</h3>
            <div class="form-group">
                <input type="text" id="joinUsernameInput" placeholder="Enter your username">
            </div>
            <div class="form-group" id="joinPasswordGroup" style="display:none;">
                <input type="password" id="joinRoomPasswordInput" placeholder="Room password">
            </div>
            <div class="modal-buttons">
                <button class="secondary-btn" onclick="window.closeModal()">Cancel</button>
                <button class="primary-btn" onclick="window.confirmJoinRoom()">
                    <i data-lucide="log-in"></i> Join
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js"; 
        import { 
            getDatabase, ref, set, onValue, push, remove,
            serverTimestamp, query, orderByChild, limitToLast, equalTo,
            onDisconnect 
        } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";
      
        const firebaseConfig = {
            apiKey: "AIzaSyBLCRiYQuFNywe26ckNPaOay8tm3UHT9vA",
            authDomain: "liqrid.firebaseapp.com",
            projectId: "liqrid",
            storageBucket: "liqrid.appspot.com",
            messagingSenderId: "196493662290",
            appId: "1:196493662290:web:17546d72fed9a06677278b",
            measurementId: "G-0491BG4LP9",
            // databaseURL: "https://liqrid-default-rtdb.firebaseio.com" // Ensure this matches your RTDB URL
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app); 

        let canvas, ctx;
        let currentTool = 'brush';
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let localUsername = '';
        let firebaseUser = null; 
        let currentRoomId = null;
        let currentRoomData = null; 
        let undoStack = [];
        let redoStack = [];

        let roomsListListenerUnsubscribe = null;
        let roomUsersListenerUnsubscribe = null;
        let roomChatListenerUnsubscribe = null;
        let roomCanvasListenerUnsubscribe = null;
        
        let sidebarEl, appContainerEl, mainMobileMenuBtnEl, sidebarMobileMenuBtnEl, currentRoomTitleEl;
        let roomNameInputEl, usernameInputEl, isPrivateCheckboxEl;
        let joinUsernameInputEl, joinRoomPasswordInputEl, joinPasswordGroupEl, joinModalTitleEl;
        let authStatusEl; 

        document.addEventListener('DOMContentLoaded', () => {
            authStatusEl = document.createElement('div');
            authStatusEl.style.cssText = `
                position: fixed; bottom: 5px; left: 5px; padding: 5px 10px;
                background: rgba(255,255,255,0.1); border: 1px solid white;
                border-radius: 3px; font-size: 10px; z-index: 2000; color: white;`;
            document.body.appendChild(authStatusEl);
            initAppLogic();
        });

        function initAppLogic() {
            console.log("App Logic Initializing...");
            canvas = document.getElementById('canvas');
            if (!canvas) { console.error("FATAL: Canvas element not found!"); return; }
            ctx = canvas.getContext('2d');
            
            cacheDOMElements();
            if (!roomNameInputEl) { 
                 console.error("FATAL: Critical DOM elements (e.g., roomNameInput) not found! HTML structure might be broken or IDs incorrect."); 
                 return; 
            }

            document.getElementById('colorPicker').value = '#000000';
            setupGlobalEventListeners(); 
            setupCanvasInteractionEvents();
            setupMobileSupportUI();
            saveCanvasState(); 
            lucide.createIcons();
            
            onAuthStateChanged(auth, (user) => {
                console.log("Auth state changed. User:", user ? user.uid : "null");
                if (user) {
                    firebaseUser = user; 
                    authStatusEl.textContent = `Authenticated (UID: ${user.uid.substring(0,6)}...)`;
                    authStatusEl.style.borderColor = 'lime';
                    
                    const savedUsername = localStorage.getItem('canvasChatUsername_v9_auth');
                    if (savedUsername) {
                        localUsername = savedUsername;
                    } else {
                        const newUsername = prompt("Please enter your username:", "User" + Math.floor(Math.random() * 100));
                        if (newUsername && newUsername.trim()) {
                            localUsername = newUsername.trim();
                        } else {
                            localUsername = "User" + Math.floor(Math.random() * 1000); // Default if prompt is cancelled or empty
                        }
                    }
                    usernameInputEl.value = localUsername; // Sync input fields
                    joinUsernameInputEl.value = localUsername;
                    localStorage.setItem('canvasChatUsername_v9_auth', localUsername); // Save/update

                    console.log("User authenticated, username set to:", localUsername);
                    startListeningToPublicRooms(); 
                } else {
                    firebaseUser = null;
                    localUsername = ''; // Clear username if not authenticated
                    authStatusEl.textContent = 'Authenticating...';
                    authStatusEl.style.borderColor = 'orange';
                    console.log("User is signed out, attempting to sign in anonymously.");
                    signInAnonymously(auth)
                        .catch((error) => {
                            console.error("Anonymous sign-in failed:", error);
                            authStatusEl.textContent = `Auth FAILED: ${error.code}`;
                            authStatusEl.style.borderColor = 'red';
                            alert("Authentication failed: " + error.message + ". Ensure Anonymous Sign-In is enabled in your Firebase project. Check console for details.");
                        });
                }
            });
        }

        function cacheDOMElements() {
            sidebarEl = document.getElementById('sidebar');
            appContainerEl = document.getElementById('appContainer');
            mainMobileMenuBtnEl = document.getElementById('mainMobileMenuBtn');
            if (sidebarEl) sidebarMobileMenuBtnEl = sidebarEl.querySelector('.mobile-menu-btn');
            currentRoomTitleEl = document.getElementById('currentRoomTitle');
            roomNameInputEl = document.getElementById('roomNameInput');
            usernameInputEl = document.getElementById('usernameInput');
            isPrivateCheckboxEl = document.getElementById('isPrivateCheckbox');
            joinUsernameInputEl = document.getElementById('joinUsernameInput');
            joinRoomPasswordInputEl = document.getElementById('joinRoomPasswordInput');
            joinPasswordGroupEl = document.getElementById('joinPasswordGroup');
            joinModalTitleEl = document.getElementById('joinModalTitle');
        }

        function setupGlobalEventListeners() {
             document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!firebaseUser) { alert("Please wait for authentication."); return; }
                    currentTool = btn.dataset.tool;
                    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    canvas.style.cursor = currentTool === 'select' ? 'default' : 'crosshair';
                });
            });
            document.getElementById('imageUpload').addEventListener('change', (e) => window.handleImageUpload(e));
            document.getElementById('messageInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); window.sendMessage(); }
            });
            usernameInputEl.addEventListener('change', (e) => { // Use change, not input, to save on blur
                localUsername = e.target.value.trim();
                if(localUsername) localStorage.setItem('canvasChatUsername_v9_auth', localUsername);
                joinUsernameInputEl.value = localUsername; 
            });
             joinUsernameInputEl.addEventListener('change', (e) => {
                localUsername = e.target.value.trim();
                if(localUsername) localStorage.setItem('canvasChatUsername_v9_auth', localUsername);
                usernameInputEl.value = localUsername; 
            });
        }
        
        function startListeningToPublicRooms() {
            if (!firebaseUser) { console.log("Cannot listen to rooms: not authenticated."); return; }
            console.log("Starting to listen to public rooms.");
            
            if (roomsListListenerUnsubscribe) roomsListListenerUnsubscribe(); 

            const roomsQuery = query(ref(db, 'rooms'), orderByChild('metadata/isPrivate'), equalTo(false));
            roomsListListenerUnsubscribe = onValue(roomsQuery, snapshot => {
                const roomsData = snapshot.val() || {};
                console.log("Public rooms data received:", Object.keys(roomsData).length > 0 ? roomsData : "No public rooms");
                renderRoomsList(roomsData);
            }, error => {
                console.error("Error fetching public rooms:", error);
                if (error.code === 'PERMISSION_DENIED') {
                    addSystemMessageToChat('Error: Cannot access rooms list. Check Firebase rules.');
                } else { addSystemMessageToChat('Error fetching public rooms: ' + error.message); }
            });
        }

        function renderRoomsList(roomsData) {
            const roomListEl = document.getElementById('roomList');
            roomListEl.innerHTML = ''; 
            const roomIds = Object.keys(roomsData);
            if (roomIds.length === 0) {
                roomListEl.innerHTML = '<p style="color: rgba(255,255,255,0.5); font-style:italic;">No active public rooms.</p>';
                return;
            }
            roomIds.forEach(roomId => {
                const room = roomsData[roomId];
                if (!room.metadata) { console.warn("Room data missing metadata:", roomId, room); return; }
                const roomDiv = document.createElement('div');
                roomDiv.className = 'room-item';
                if (roomId === currentRoomId) roomDiv.classList.add('active');
                const userCount = room.users ? Object.keys(room.users).length : 0;
                roomDiv.innerHTML = `<div class="room-name">${room.metadata.name}</div><div class="room-info">${userCount} user(s) online</div>`;
                roomDiv.addEventListener('click', () => {
                    if (!firebaseUser) { alert("Please wait for authentication to complete."); return; }
                    if (currentRoomId !== roomId) {
                        console.log(`Attempting to join room: ${roomId}`);
                        promptUserToJoinRoom(roomId, room.metadata);
                    }
                });
                roomListEl.appendChild(roomDiv);
            });
        }
        
        window.createRoom = function() { 
            console.log("window.createRoom function called by button click.");
            if (!firebaseUser) { alert("Authentication required to create a room."); console.log("Create room aborted: not authenticated."); return; }
            if (!localUsername.trim()) { 
                alert("Please set your username before creating a room.");
                usernameInputEl.focus(); console.log("Create room aborted: no username."); return;
            }

            const roomName = roomNameInputEl.value.trim();
            const isPrivate = isPrivateCheckboxEl.checked;
            if (!roomName) { alert('Please enter a room name.'); console.log("Create room aborted: no room name."); return; }
            
            console.log(`Attempting to create room in Firebase: Name: ${roomName}, Private: ${isPrivate}, User: ${localUsername} (UID: ${firebaseUser.uid})`);

            let password = null;
            if (isPrivate) {
                password = prompt('Enter room password (min 6 chars):');
                if (!password || password.length < 6) { alert('Private rooms require a password of at least 6 characters.'); console.log("Create private room aborted: invalid password."); return; }
            }
            
            if (currentRoomId) detachListenersAndLeaveCurrentRoom(); 

            const newRoomRef = push(ref(db, 'rooms')); // Generate new key for the room
            const newRoomId = newRoomRef.key;
            console.log("Firebase generated New Room ID:", newRoomId);

            const roomMetadata = {
                name: roomName, isPrivate: isPrivate, creatorUsername: localUsername,
                creatorId: firebaseUser.uid, createdAt: serverTimestamp()
            };
            if (isPrivate) roomMetadata.passwordHash = password; // INSECURE: FOR DEMO ONLY. HASH IN PRODUCTION.
            
            const initialCanvasState = canvas.toDataURL(); // Get initial (empty) canvas state

            // Data to be set for the new room
            const newRoomData = { 
                metadata: roomMetadata, 
                fullCanvasDataUrl: initialCanvasState,
                users: {}, // Initialize users object
                chatMessages: {} // Initialize chatMessages object
            };
            
            console.log("Data to be set for new room:", newRoomData);

            set(newRoomRef, newRoomData)
                .then(() => {
                    console.log(`Room "${roomName}" (ID: ${newRoomId}) data SET successfully in Firebase.`);
                    addSystemMessageToChat(`Room "${roomName}" created.`);
                    performJoinRoomLogic(newRoomId, roomMetadata); // Automatically join the room after creation
                }).catch(error => {
                    console.error("FirebaseError - Error creating room in Firebase:", error);
                    alert(`Error creating room: ${error.message}. Check Firebase rules (ensure authenticated users can write to /rooms/{newRoomId}) and browser console for PERMISSION_DENIED errors.`);
                });
        }

        let selectedRoomIdToJoin = null;
        let selectedRoomMetadataToJoin = null;

        function promptUserToJoinRoom(roomId, roomMetadata) {
            if (!firebaseUser) { alert("Authentication required."); return; }
            if (!localUsername.trim()) { 
                alert("Please set your username before joining a room.");
                usernameInputEl.focus(); return;
            }
            selectedRoomIdToJoin = roomId; selectedRoomMetadataToJoin = roomMetadata;
            joinModalTitleEl.textContent = `Join Room: ${roomMetadata.name}`;
            joinUsernameInputEl.value = localUsername; 
            joinPasswordGroupEl.style.display = roomMetadata.isPrivate ? 'block' : 'none';
            joinRoomPasswordInputEl.value = '';
            document.getElementById('joinModal').classList.remove('hidden');
        }
        
        window.confirmJoinRoom = function() { 
            if (!firebaseUser) { alert("Authentication required."); return; }
            const passwordAttempt = joinRoomPasswordInputEl.value;
            const usernameForJoin = joinUsernameInputEl.value.trim(); 
             if (!usernameForJoin) { alert("Please enter your username."); return; }
            localUsername = usernameForJoin; 
            localStorage.setItem('canvasChatUsername_v9_auth', localUsername);

            if (selectedRoomMetadataToJoin.isPrivate) {
                onValue(ref(db, `rooms/${selectedRoomIdToJoin}/metadata/passwordHash`), (snapshot) => {
                    const correctPasswordHash = snapshot.val();
                    if (passwordAttempt !== correctPasswordHash) { alert('Incorrect password.'); return; }
                    if (currentRoomId) detachListenersAndLeaveCurrentRoom();
                    performJoinRoomLogic(selectedRoomIdToJoin, selectedRoomMetadataToJoin);
                }, { onlyOnce: true }); 
            } else {
                if (currentRoomId) detachListenersAndLeaveCurrentRoom();
                performJoinRoomLogic(selectedRoomIdToJoin, selectedRoomMetadataToJoin);
            }
        }

        function performJoinRoomLogic(roomId, roomMeta) {
            if (!firebaseUser) { console.error("Cannot join room: not authenticated."); return; }
            console.log(`Performing join logic for room ${roomId}, user ${localUsername} (UID: ${firebaseUser.uid})`);
            currentRoomId = roomId; currentRoomData = roomMeta; 
            
            const userPresenceRef = ref(db, `rooms/${currentRoomId}/users/${firebaseUser.uid}`);
            set(userPresenceRef, localUsername).then(() => { 
                console.log(`User ${localUsername} added to room ${roomId} users list in Firebase.`);
                const disconnectHandler = onDisconnect(userPresenceRef);
                disconnectHandler.remove(); 
                
                currentRoomTitleEl.textContent = currentRoomData.name;
                closeModal();
                if (sidebarEl.classList.contains('open') && window.innerWidth <= 768) window.toggleSidebar();
                addSystemMessageToChat(`You joined "${currentRoomData.name}".`);
                
                document.querySelectorAll('.room-item.active').forEach(el => el.classList.remove('active'));
                const roomItems = document.getElementById('roomList').children;
                for (let item of roomItems) { // Find and activate room item
                    if (item.querySelector('.room-name') && item.querySelector('.room-name').textContent === currentRoomData.name) {
                         item.classList.add('active'); break;
                    }
                }
                startListeningToCurrentRoomChanges();
            }).catch(error => {
                console.error("FirebaseError - Error joining room (setting user presence):", error);
                alert(`Failed to join room. Check Firebase rules (ensure authenticated users can write to /rooms/${roomId}/users/${firebaseUser.uid}) and console. Error: ${error.message}`);
                currentRoomId = null; currentRoomData = null; 
            });
        }
        
        function detachListenersAndLeaveCurrentRoom() {
            if (!currentRoomId || !firebaseUser) return;
            console.log(`Leaving room ${currentRoomId}. Detaching listeners.`);
            addSystemMessageToChat(`You left "${currentRoomTitleEl.textContent}".`);

            if (roomUsersListenerUnsubscribe) { roomUsersListenerUnsubscribe(); roomUsersListenerUnsubscribe = null; console.log("Detached users listener for room:", currentRoomId); }
            if (roomChatListenerUnsubscribe) { roomChatListenerUnsubscribe(); roomChatListenerUnsubscribe = null; console.log("Detached chat listener for room:", currentRoomId); }
            if (roomCanvasListenerUnsubscribe) { roomCanvasListenerUnsubscribe(); roomCanvasListenerUnsubscribe = null; console.log("Detached canvas listener for room:", currentRoomId); }

            const userPresenceRef = ref(db, `rooms/${currentRoomId}/users/${firebaseUser.uid}`);
            const disconnectHandler = onDisconnect(userPresenceRef);
            disconnectHandler.cancel(); 
            remove(userPresenceRef).catch(e => console.warn("Error removing user on leave:", e));

            currentRoomId = null; currentRoomData = null;
            currentRoomTitleEl.textContent = 'Canvas Area';
            document.getElementById('usersList').innerHTML = '';
            document.getElementById('chatMessages').innerHTML = ''; 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveCanvasState(); 
            // renderRoomsList({}); // This might clear the list prematurely if listener isn't fast
            if (firebaseUser) startListeningToPublicRooms(); // Re-fetch public rooms, which will update the list
        }

        function startListeningToCurrentRoomChanges() {
            if (!currentRoomId || !firebaseUser) { console.log("Cannot listen to room changes: no current room or not authenticated."); return;}
            console.log(`Starting to listen to changes in room ${currentRoomId}`);

            const usersRefPath = `rooms/${currentRoomId}/users`;
            if (roomUsersListenerUnsubscribe) roomUsersListenerUnsubscribe();
            roomUsersListenerUnsubscribe = onValue(ref(db, usersRefPath), snapshot => {
                const users = snapshot.val() || {};
                console.log("Room users update for room", currentRoomId, ":", users);
                renderUsersList(Object.values(users));
                 if (currentRoomData && !currentRoomData.isPrivate) { // Update public list for user count changes
                    if (firebaseUser) startListeningToPublicRooms(); 
                 }
            });

            const chatQuery = query(ref(db, `rooms/${currentRoomId}/chatMessages`), orderByChild('timestamp'), limitToLast(50));
            if (roomChatListenerUnsubscribe) roomChatListenerUnsubscribe();
            roomChatListenerUnsubscribe = onValue(chatQuery, snapshot => { 
                console.log("Chat update for room", currentRoomId);
                document.getElementById('chatMessages').innerHTML = ''; 
                snapshot.forEach(childSnapshot => {
                    const msg = childSnapshot.val();
                    if (msg) renderChatMessage(msg.username, msg.message, msg.userId === firebaseUser.uid);
                });
            });

            const canvasStateRefPath = `rooms/${currentRoomId}/fullCanvasDataUrl`;
            if (roomCanvasListenerUnsubscribe) roomCanvasListenerUnsubscribe();
            roomCanvasListenerUnsubscribe = onValue(ref(db, canvasStateRefPath), snapshot => {
                const imageDataUrl = snapshot.val();
                console.log("Canvas state update received for room " + currentRoomId + (imageDataUrl ? " (has data)" : " (no data/cleared)"));
                if (imageDataUrl) {
                    loadCanvasFromDataUrl(imageDataUrl);
                } else { 
                    ctx.clearRect(0,0,canvas.width, canvas.height);
                    saveCanvasState(); 
                }
            });
        }

        function renderUsersList(usersArray) {
            const usersListEl = document.getElementById('usersList');
            usersListEl.innerHTML = usersArray.map(user => 
                `<span class="user-item ${user === localUsername ? 'me' : ''}">${user}</span>`
            ).join('');
        }

        function renderChatMessage(author, message, isOwnMessage = false) {
            const chatMessagesEl = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            if (isOwnMessage) messageDiv.classList.add('own-message');
            const authorSpan = document.createElement('span');
            authorSpan.className = 'message-author';
            authorSpan.textContent = author === localUsername && isOwnMessage ? 'You' : author;
            const textSpan = document.createElement('span');
            textSpan.className = 'message-text';
            textSpan.textContent = message; 
            messageDiv.appendChild(authorSpan); messageDiv.appendChild(textSpan);
            chatMessagesEl.appendChild(messageDiv);
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }
        function addSystemMessageToChat(message) {
            renderChatMessage('System', message, false);
        }

        window.sendMessage = function() { 
            if (!firebaseUser) { alert("Authentication required to send messages."); return; }
            if (!currentRoomId) { addSystemMessageToChat('You must be in a room to send messages.'); return; }
            if (!localUsername.trim()) { addSystemMessageToChat('Please set your username to send messages.'); return; }
            
            const inputEl = document.getElementById('messageInput');
            const messageText = inputEl.value.trim();
            if (messageText) {
                push(ref(db, `rooms/${currentRoomId}/chatMessages`), {
                    username: localUsername, userId: firebaseUser.uid, 
                    message: messageText, timestamp: serverTimestamp()
                }).then(() => inputEl.value = '')
                  .catch(e => {
                    console.error("FirebaseError - Send message error:", e);
                    alert("Error sending message: " + e.message);
                  });
            }
        }

        // --- Canvas Drawing Logic ---
        function getMousePos(e) { 
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
            const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
            if (clientX === undefined || clientY === undefined) return [lastX, lastY]; // Fallback if no coords
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return [(clientX - rect.left) * scaleX, (clientY - rect.top) * scaleY];
        }

        function startDrawing(e) {
            if (!currentRoomId || !firebaseUser) return;
            e.preventDefault(); isDrawing = true;
            [lastX, lastY] = getMousePos(e);
            if (currentTool === 'fill') {
                performFloodFill(Math.floor(lastX), Math.floor(lastY)); 
                saveCanvasState(); 
                syncCanvasStateToFirebase(); 
                isDrawing = false; return;
            }
            if (currentTool === 'brush' || currentTool === 'eraser') { 
                const size = parseFloat(document.getElementById('brushSize').value);
                ctx.beginPath(); ctx.arc(lastX, lastY, size / 2, 0, Math.PI * 2);
                ctx.fillStyle = currentTool === 'brush' ? document.getElementById('colorPicker').value : 'rgba(0,0,0,0)';
                if (currentTool === 'eraser') ctx.globalCompositeOperation = 'destination-out';
                else ctx.globalCompositeOperation = 'source-over';
                ctx.fill(); ctx.globalCompositeOperation = 'source-over'; 
            }
        }

        function draw(e) {
            if (!isDrawing || !currentRoomId || !firebaseUser) return;
            e.preventDefault();
            const [currentX, currentY] = getMousePos(e);
            const color = document.getElementById('colorPicker').value;
            const size = parseFloat(document.getElementById('brushSize').value);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; 
            if (currentTool === 'brush') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = color; ctx.lineWidth = size;
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out'; 
                ctx.lineWidth = size;
            } else return;
            ctx.beginPath(); ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY); ctx.stroke();
            [lastX, lastY] = [currentX, currentY];
        }

        function stopDrawing(e) {
            if ((!isDrawing && currentTool !== 'fill') || !currentRoomId || !firebaseUser) {
                isDrawing = false; return;
            }
            isDrawing = false; 
            if (e) e.preventDefault();
            ctx.globalCompositeOperation = 'source-over'; 
            saveCanvasState(); 
            syncCanvasStateToFirebase(); 
        }
        
        function syncCanvasStateToFirebase() {
            if (!currentRoomId || !firebaseUser) { console.warn("Cannot sync canvas: no room or not authed."); return; }
            console.log("Attempting to sync canvas state to Firebase for room:", currentRoomId);
            const imageDataUrl = canvas.toDataURL(); 
            set(ref(db, `rooms/${currentRoomId}/fullCanvasDataUrl`), imageDataUrl)
                .then(() => console.log("Canvas state synced successfully for room:", currentRoomId))
                .catch(error => {
                    console.error("FirebaseError - Error updating canvas state in Firebase:", error);
                    if (error.code === 'PERMISSION_DENIED') {
                        addSystemMessageToChat('Error: Canvas update denied. Check Firebase rules.');
                    }
                });
        }

        function performFloodFill(startX, startY) { 
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data; const startPos = (startY * canvas.width + startX) * 4;
            const startR = data[startPos], startG = data[startPos + 1], startB = data[startPos + 2];
            const fillColorHex = document.getElementById('colorPicker').value;
            const fillColorRgb = hexToRgb(fillColorHex); if (!fillColorRgb) return; 
            const [fillR, fillG, fillB] = fillColorRgb;
            if (startR === fillR && startG === fillG && startB === fillB) return; 
            const q = [[startX, startY]]; 
            while (q.length > 0) {
                const [x, y] = q.shift();
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                const currentPos = (y * canvas.width + x) * 4;
                // Check if pixel is already the fill color or not the target color
                if ((data[currentPos] === fillR && data[currentPos+1] === fillG && data[currentPos+2] === fillB) ||
                    (data[currentPos] !== startR || data[currentPos+1] !== startG || data[currentPos+2] !== startB) ) {
                    continue;
                }
                data[currentPos] = fillR; data[currentPos+1] = fillG; data[currentPos+2] = fillB; data[currentPos+3] = 255;
                q.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            ctx.putImageData(imageData, 0, 0);
        }
        function hexToRgb(hex) { 
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
        }

        window.handleImageUpload = function(e) { 
            if (!currentRoomId || !firebaseUser) { alert("Please join a room and be authenticated to import images."); e.target.value = null; return; }
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const hRatio = canvas.width / img.width, vRatio = canvas.height / img.height;
                    const ratio = Math.min(hRatio, vRatio, 1); 
                    const centerX = (canvas.width - img.width * ratio) / 2, centerY = (canvas.height - img.height * ratio) / 2;
                    ctx.drawImage(img, 0, 0, img.width, img.height, centerX, centerY, img.width * ratio, img.height * ratio);
                    saveCanvasState(); syncCanvasStateToFirebase();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file); e.target.value = null; 
        }

        function saveCanvasState() { 
            if (undoStack.length >= 20) undoStack.shift(); 
            undoStack.push(canvas.toDataURL());
            redoStack = []; updateUndoRedoButtonsUI();
        }
        window.undo = function() { 
            if (!firebaseUser || !currentRoomId) return;
            if (undoStack.length > 1) { 
                redoStack.push(undoStack.pop());
                applyLocalCanvasStateForUndoRedo(undoStack[undoStack.length - 1]);
            }
        }
        window.redo = function() { 
            if (!firebaseUser || !currentRoomId) return;
            if (redoStack.length > 0) {
                const imageData = redoStack.pop();
                undoStack.push(imageData);
                applyLocalCanvasStateForUndoRedo(imageData);
            }
        }
        function applyLocalCanvasStateForUndoRedo(imageDataUrl) { 
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                ctx.drawImage(img, 0, 0);
                if(firebaseUser && currentRoomId) syncCanvasStateToFirebase(); 
                updateUndoRedoButtonsUI();
            };
            img.src = imageDataUrl;
        }
        function updateUndoRedoButtonsUI(){ 
            document.querySelector('.tool-btn[onclick="window.undo()"]').disabled = undoStack.length <= 1;
            document.querySelector('.tool-btn[onclick="window.redo()"]').disabled = redoStack.length === 0;
        }

        window.clearCanvas = function() { 
            if (!currentRoomId || !firebaseUser) { alert("Must be in a room and authenticated to clear canvas."); return; }
            if (confirm("Clear canvas for everyone in this room?")) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                saveCanvasState(); syncCanvasStateToFirebase();
            }
        }
        window.downloadCanvas = function() { 
            const link = document.createElement('a');
            link.download = `canvas-${currentRoomData ? currentRoomData.name.replace(/\s+/g, '_') : 'drawing'}.png`;
            link.href = canvas.toDataURL('image/png'); link.click();
        }

        function loadCanvasFromDataUrl(canvasDataUrl) { 
            console.log("Loading canvas from data URL (remote update)");
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0);
                undoStack = [canvas.toDataURL()]; redoStack = [];
                updateUndoRedoButtonsUI();
            };
            img.onerror = () => { console.error("Error loading image from data URL for canvas.")}
            img.src = canvasDataUrl;
        }

        // --- UI & Mobile Helper Functions ---
        function setupMobileSupportUI() { 
            const isMobile = window.innerWidth <= 768;
            if (mainMobileMenuBtnEl) mainMobileMenuBtnEl.style.display = isMobile ? 'flex' : 'none';
            if (sidebarMobileMenuBtnEl) sidebarMobileMenuBtnEl.style.display = isMobile ? 'flex' : 'none';
            if (!isMobile && sidebarEl) { sidebarEl.classList.remove('open'); appContainerEl.classList.remove('sidebar-open'); }
            if (isMobile && sidebarEl && sidebarEl.classList.contains('open')) { window.toggleSidebar(); }
        }
        window.addEventListener('resize', setupMobileSupportUI);

        window.toggleSidebar = function() { 
            if (!sidebarEl || !appContainerEl || !sidebarMobileMenuBtnEl) return;
            sidebarEl.classList.toggle('open'); appContainerEl.classList.toggle('sidebar-open');
            const sidebarIcon = sidebarMobileMenuBtnEl.querySelector('i');
            if(sidebarIcon) sidebarIcon.setAttribute('data-lucide', sidebarEl.classList.contains('open') ? 'x' : 'menu');
            lucide.createIcons(); 
        }
        window.closeModal = function() { 
            document.getElementById('joinModal').classList.add('hidden');
            joinRoomPasswordInputEl.value = '';
        }
        
        function setupCanvasInteractionEvents() { 
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing); 
            canvas.addEventListener('touchstart', (e) => { 
                if (!firebaseUser || !currentRoomId) return; e.preventDefault();
                const touch = e.touches[0] || e.changedTouches[0];
                if (!touch) return;
                const mockEvent = new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY });
                startDrawing(mockEvent);
            }, { passive: false }); 
            canvas.addEventListener('touchmove', (e) => { 
                if (!isDrawing || !firebaseUser || !currentRoomId) return; e.preventDefault(); 
                const touch = e.touches[0] || e.changedTouches[0];
                if (!touch) return;
                const mockEvent = new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY });
                draw(mockEvent);
            }, { passive: false });
            canvas.addEventListener('touchend', (e) => { 
                if (!firebaseUser || !currentRoomId) return; e.preventDefault();
                const touch = e.changedTouches[0]; 
                const clientX = touch ? touch.clientX : lastX; 
                const clientY = touch ? touch.clientY : lastY;
                const mockEvent = new MouseEvent('mouseup', { clientX: clientX, clientY: clientY });
                stopDrawing(mockEvent);
            }, { passive: false });
        }
    </script>
</body>
</html>
