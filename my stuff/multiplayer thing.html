<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Canvas - Simpler Firebase</title>
    
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* --- CSS is the same as the previous version --- */
        /* For brevity, I'll omit the full CSS block here. Assume it's identical to the one in the last full HTML response. */
        /* Paste the full CSS from the previous response here */
        :root {
            --black: #000000;
            --white: #FFFFFF;
            --border-color: var(--white);
            --text-color: var(--white);
            --bg-color: var(--black);
            --interactive-bg: var(--white);
            --interactive-text: var(--black);
            --interactive-border: var(--white);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* Helps prevent scrolling on canvas touch */
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            background: var(--bg-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-color);
        }

        .header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
        }

        .header h1, .header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
        }
        .mobile-menu-btn { 
            display: none; 
            background: transparent;
            color: var(--white);
            border: 1px solid var(--white);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            z-index: 101;
        }
        .mobile-menu-btn:hover {
            background: var(--white);
            color: var(--black);
        }


        .section {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .section:last-child {
            border-bottom: none;
        }
        .room-list-section { 
             flex: 1; display: flex; flex-direction: column;
        }


        .section h3 {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-color);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom:15px;
        }

        .form-group input[type="text"],
        .form-group input[type="password"] {
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            background: var(--bg-color);
            color: var(--text-color);
        }
        .form-group input[type="text"]::placeholder,
        .form-group input[type="password"]::placeholder {
            color: rgba(255,255,255,0.5);
        }


        .form-group label {
            display: flex;
            align-items: center;
            font-size: 14px;
            color: var(--text-color);
        }
        .form-group input[type="checkbox"] {
            margin-right: 8px;
            accent-color: var(--white); 
        }

        button.primary-btn, button.secondary-btn {
            padding: 10px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        button.primary-btn {
            background: var(--interactive-bg);
            color: var(--interactive-text);
            border: 1px solid var(--interactive-border);
        }
        button.primary-btn:hover {
            background: var(--bg-color);
            color: var(--text-color);
        }
        button.secondary-btn {
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        button.secondary-btn:hover {
            background: var(--interactive-bg);
            color: var(--interactive-text);
        }

        .room-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 0 20px 0; 
        }

        .room-item {
            padding: 12px;
            margin-bottom: 8px;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .room-item:hover {
            border-color: var(--white);
            background: rgba(255,255,255,0.1);
        }
        .room-item.active {
            background: var(--interactive-bg);
            color: var(--interactive-text);
            border-color: var(--interactive-bg);
        }
        .room-item.active .room-name,
        .room-item.active .room-info {
             color: var(--interactive-text);
        }

        .room-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-color);
        }
        .room-info {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            margin-top: 4px;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            border-bottom: 1px solid var(--border-color);
        }
        .canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 60px; 
            overflow: hidden; 
            background: var(--white); 
        }
        #canvas {
            display: block;
            cursor: crosshair;
            background: var(--white); 
        }

        .toolbar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--bg-color);
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 5px;
            overflow-x: auto;
        }
        .tool-btn {
            padding: 8px;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            min-width: 40px; 
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .tool-btn svg { width: 20px; height: 20px; }
        .tool-btn:hover { background: var(--interactive-bg); color: var(--interactive-text); }
        .tool-btn.active { background: var(--interactive-bg); color: var(--interactive-text); border-color: var(--interactive-bg); }
        .tool-btn:disabled { opacity: 0.5; cursor: not-allowed; background: var(--bg-color); color: var(--text-color); border-color: var(--border-color); }

        input[type="color"], input[type="range"] { margin: 0 5px; }
        input[type="color"] {
            width: 36px; height: 36px; border: 1px solid var(--border-color);
            padding: 2px; background: var(--bg-color); border-radius: 4px;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 2px; }
        .size-slider { width: 100px; accent-color: var(--white); }

        .chat-section { height: 250px; display: flex; flex-direction: column; background: var(--bg-color); }
        .users-list {
            padding: 10px 15px; border-bottom: 1px solid var(--border-color);
            background: var(--bg-color); flex-shrink: 0;
            white-space: nowrap; overflow-x: auto;
        }
        .user-item {
            display: inline-block; padding: 4px 10px; margin: 2px;
            background: var(--bg-color); color: var(--text-color);
            border: 1px solid var(--border-color); border-radius: 15px; font-size: 12px;
        }
        .user-item.me { background: var(--white); color: var(--black); border-color: var(--white); }

        .chat-messages { flex: 1; overflow-y: auto; padding: 15px; }
        .message {
            margin-bottom: 10px; padding: 8px 12px; background: var(--bg-color);
            border: 1px solid var(--border-color); border-radius: 6px;
            font-size: 14px; max-width: 85%;
        }
        .message.own-message {
            margin-left: auto; background: var(--interactive-bg);
            color: var(--interactive-text); border-color: var(--interactive-bg);
        }
        .message.own-message .message-author{ color: var(--interactive-text); }
        .message-author { font-weight: 600; color: var(--text-color); display: block; margin-bottom: 3px; }
        .message-text { word-wrap: break-word; }

        .chat-input-area { display: flex; padding: 15px; gap: 10px; border-top: 1px solid var(--border-color); }
        .chat-input-area input[type="text"] {
            flex: 1; padding: 10px 12px; border: 1px solid var(--border-color);
            border-radius: 4px; font-size: 14px; background: var(--bg-color); color: var(--text-color);
        }
        .chat-input-area input[type="text"]::placeholder { color: rgba(255,255,255,0.5); }
        .chat-input-area button {
            padding: 10px; background: var(--interactive-bg); color: var(--interactive-text);
            border: 1px solid var(--interactive-border); border-radius: 4px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            width: 44px; height: 44px;
        }
        .chat-input-area button svg { width: 20px; height: 20px; }
        .chat-input-area button:hover { background: var(--bg-color); color: var(--text-color); }

        .modal {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85); display: flex;
            align-items: center; justify-content: center;
            z-index: 1000; padding: 20px;
        }
        .modal-content {
            background: var(--bg-color); padding: 25px; border-radius: 6px;
            border: 1px solid var(--border-color); max-width: 400px; width: 100%;
        }
        .modal-content h3 { font-size: 18px; margin-bottom: 20px; color: var(--text-color); }
        .modal-content .form-group { margin-bottom: 20px; }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }

        .hidden { display: none !important; }

        @media (max-width: 768px) {
            .sidebar {
                width: 100%; position: absolute; z-index: 100;
                left: -100%; transition: left 0.3s ease-in-out; border-right: none; 
            }
            .sidebar.open { left: 0; }
            .main-content { margin-left:0; }
            .mobile-menu-btn { display: flex; position: absolute; top: 12px; left: 15px; }
            .header h1, .header h2 { margin-left: 45px; } /* Space for menu button */
        }
        .selection-handles { position: absolute; pointer-events: none; }
        .handle {
            position: absolute; width: 8px; height: 8px; background: var(--white);
            border: 1px solid var(--black); border-radius: 50%;
            pointer-events: all; cursor: pointer;
        }
        .handle.rotate { background: var(--white); border-radius: 0; transform: rotate(45deg); }
    </style>
</head>
<body>
    <!-- --- HTML Body is the same as the previous version --- -->
    <!-- Paste the full BODY from the previous response here -->
    <div class="app-container" id="appContainer">
        <div class="sidebar" id="sidebar">
            <div class="header">
                <button class="mobile-menu-btn" onclick="window.toggleSidebar()">
                    <i data-lucide="x"></i>
                </button>
                <h1>Canvas Rooms</h1>
            </div>
            
            <div class="section">
                <h3>Create Room</h3>
                <div class="form-group">
                    <input type="text" id="roomNameInput" placeholder="Room name">
                    <input type="text" id="usernameInput" placeholder="Your username">
                    <label>
                        <input type="checkbox" id="isPrivateCheckbox"> Private room
                    </label>
                </div>
                <button class="primary-btn" onclick="window.createRoom()">
                    <i data-lucide="plus-circle"></i> Create Room
                </button>
            </div>
            
            <div class="section room-list-section">
                <h3>Active Rooms</h3>
                <div class="room-list" id="roomList">
                    <!-- Rooms will be populated by JS -->
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="header main-header">
                 <button class="mobile-menu-btn" id="mainMobileMenuBtn" onclick="window.toggleSidebar()">
                    <i data-lucide="menu"></i>
                </button>
                <h2 id="currentRoomTitle">Canvas Area</h2>
            </div>

            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="canvas" width="1200" height="800"></canvas>
                    <div class="selection-handles hidden" id="selectionHandles"></div>
                </div>
                
                <div class="toolbar">
                    <button class="tool-btn active" data-tool="brush" title="Brush"><i data-lucide="paint-brush"></i></button>
                    <button class="tool-btn" data-tool="eraser" title="Eraser"><i data-lucide="eraser"></i></button>
                    <button class="tool-btn" data-tool="fill" title="Fill Bucket"><i data-lucide="paint-bucket"></i></button>
                    <button class="tool-btn" data-tool="select" title="Select"><i data-lucide="mouse-pointer-click"></i></button>
                    <input type="color" id="colorPicker" value="#000000" title="Color Picker">
                    <input type="range" id="brushSize" class="size-slider" min="1" max="50" value="5" title="Brush Size">
                    <button class="tool-btn" onclick="window.undo()" title="Undo" disabled><i data-lucide="undo-2"></i></button>
                    <button class="tool-btn" onclick="window.redo()" title="Redo" disabled><i data-lucide="redo-2"></i></button>
                    <button class="tool-btn" onclick="window.clearCanvas()" title="Clear Canvas"><i data-lucide="trash-2"></i></button>
                    <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                    <button class="tool-btn" onclick="document.getElementById('imageUpload').click();" title="Import Image"><i data-lucide="image-plus"></i></button>
                    <button class="tool-btn" onclick="window.downloadCanvas()" title="Download Image"><i data-lucide="download"></i></button>
                </div>
            </div>
            
            <div class="chat-section">
                <div class="users-list" id="usersList">
                </div>
                <div class="chat-messages" id="chatMessages">
                </div>
                <div class="chat-input-area">
                    <input type="text" id="messageInput" placeholder="Type a message...">
                    <button onclick="window.sendMessage()" title="Send Message">
                        <i data-lucide="send"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal hidden" id="joinModal">
        <div class="modal-content">
            <h3 id="joinModalTitle">Join Room</h3>
            <div class="form-group">
                <input type="text" id="joinUsernameInput" placeholder="Enter your username">
            </div>
            <div class="form-group" id="joinPasswordGroup" style="display:none;">
                <input type="password" id="joinRoomPasswordInput" placeholder="Room password">
            </div>
            <div class="modal-buttons">
                <button class="secondary-btn" onclick="window.closeModal()">Cancel</button>
                <button class="primary-btn" onclick="window.confirmJoinRoom()">
                    <i data-lucide="log-in"></i> Join
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js"; 
        import { 
            getDatabase, ref, set, onValue, push, remove,
            serverTimestamp, query, orderByChild, limitToLast, equalTo,
            onDisconnect, Unsubscribe // Added Unsubscribe for explicit listener detachment
        } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";
      
        const firebaseConfig = {
            apiKey: "AIzaSyBLCRiYQuFNywe26ckNPaOay8tm3UHT9vA",
            authDomain: "liqrid.firebaseapp.com",
            projectId: "liqrid",
            storageBucket: "liqrid.appspot.com",
            messagingSenderId: "196493662290",
            appId: "1:196493662290:web:17546d72fed9a06677278b",
            measurementId: "G-0491BG4LP9"
            // databaseURL: "https://liqrid-default-rtdb.firebaseio.com" // Add if you suspect inference issues
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app); 

        // --- Global App State ---
        let canvas, ctx;
        let currentTool = 'brush';
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        
        let localUsername = '';
        let firebaseUser = null; // Holds the authenticated Firebase user object

        let currentRoomId = null;
        let currentRoomData = null; // Holds metadata of the current room

        let undoStack = [];
        let redoStack = [];

        // --- Firebase Listener Unsubscribe Functions ---
        /** @type {Unsubscribe | null} */
        let roomsListListenerUnsubscribe = null;
        /** @type {Unsubscribe | null} */
        let roomUsersListenerUnsubscribe = null;
        /** @type {Unsubscribe | null} */
        let roomChatListenerUnsubscribe = null;
        /** @type {Unsubscribe | null} */
        let roomCanvasListenerUnsubscribe = null;
        
        // --- DOM Element Cache ---
        let sidebarEl, appContainerEl, mainMobileMenuBtnEl, sidebarMobileMenuBtnEl, currentRoomTitleEl;
        let roomNameInputEl, usernameInputEl, isPrivateCheckboxEl;
        let joinUsernameInputEl, joinRoomPasswordInputEl, joinPasswordGroupEl, joinModalTitleEl;
        let authStatusEl; 

        // --- App Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            authStatusEl = document.createElement('div'); // Create auth status display
            authStatusEl.style.cssText = `
                position: fixed; bottom: 5px; left: 5px; padding: 5px 10px;
                background: rgba(255,255,255,0.1); border: 1px solid white;
                border-radius: 3px; font-size: 10px; z-index: 2000; color: white;`;
            document.body.appendChild(authStatusEl);
            initAppLogic();
        });

        function initAppLogic() {
            console.log("initAppLogic called");
            canvas = document.getElementById('canvas');
            if (!canvas) { console.error("Canvas element not found!"); return; }
            ctx = canvas.getContext('2d');
            
            cacheDOMElements();
            if (!roomNameInputEl) { console.error("Critical DOM elements not found!"); return; }

            document.getElementById('colorPicker').value = '#000000';
            setupGlobalEventListeners(); 
            setupCanvasInteractionEvents();
            setupMobileSupportUI();
            saveCanvasState(); // Initial empty state
            lucide.createIcons();
            
            onAuthStateChanged(auth, (user) => {
                console.log("Auth state changed. User:", user ? user.uid : "null");
                if (user) {
                    firebaseUser = user; 
                    authStatusEl.textContent = `Authenticated (UID: ${user.uid.substring(0,6)}...)`;
                    authStatusEl.style.borderColor = 'lime';
                    
                    const savedUsername = localStorage.getItem('canvasChatUsername_v9_auth');
                    if (savedUsername) {
                        usernameInputEl.value = savedUsername;
                        joinUsernameInputEl.value = savedUsername; 
                        localUsername = savedUsername;
                    } else if (usernameInputEl.value.trim()) { 
                        localUsername = usernameInputEl.value.trim();
                        localStorage.setItem('canvasChatUsername_v9_auth', localUsername);
                    } else {
                        // Prompt for username if not set and not in storage
                        const newUsername = prompt("Please enter your username:", "AnonymousPainter");
                        if (newUsername && newUsername.trim()) {
                            localUsername = newUsername.trim();
                            usernameInputEl.value = localUsername;
                            joinUsernameInputEl.value = localUsername;
                            localStorage.setItem('canvasChatUsername_v9_auth', localUsername);
                        } else {
                            // Default or handle cancellation
                            localUsername = "User" + Math.floor(Math.random() * 1000);
                             usernameInputEl.value = localUsername;
                            joinUsernameInputEl.value = localUsername;
                        }
                    }
                    console.log("User authenticated, username:", localUsername);
                    startListeningToPublicRooms(); 
                } else {
                    firebaseUser = null;
                    authStatusEl.textContent = 'Authenticating...';
                    authStatusEl.style.borderColor = 'orange';
                    console.log("User is signed out, attempting to sign in anonymously.");
                    signInAnonymously(auth)
                        .catch((error) => {
                            console.error("Anonymous sign-in failed:", error);
                            authStatusEl.textContent = `Auth FAILED: ${error.code}`;
                            authStatusEl.style.borderColor = 'red';
                            alert("Authentication failed: " + error.message + ". Ensure Anonymous Sign-In is enabled in your Firebase project and check your Firebase console for errors. The app may not work correctly.");
                        });
                }
            });
        }

        function cacheDOMElements() {
            sidebarEl = document.getElementById('sidebar');
            appContainerEl = document.getElementById('appContainer');
            mainMobileMenuBtnEl = document.getElementById('mainMobileMenuBtn');
            sidebarMobileMenuBtnEl = sidebarEl.querySelector('.mobile-menu-btn');
            currentRoomTitleEl = document.getElementById('currentRoomTitle');
            roomNameInputEl = document.getElementById('roomNameInput');
            usernameInputEl = document.getElementById('usernameInput');
            isPrivateCheckboxEl = document.getElementById('isPrivateCheckbox');
            joinUsernameInputEl = document.getElementById('joinUsernameInput');
            joinRoomPasswordInputEl = document.getElementById('joinRoomPasswordInput');
            joinPasswordGroupEl = document.getElementById('joinPasswordGroup');
            joinModalTitleEl = document.getElementById('joinModalTitle');
        }

        function setupGlobalEventListeners() {
             document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!firebaseUser) { alert("Please wait for authentication."); return; }
                    currentTool = btn.dataset.tool;
                    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    canvas.style.cursor = currentTool === 'select' ? 'default' : 'crosshair';
                });
            });
            document.getElementById('imageUpload').addEventListener('change', (e) => window.handleImageUpload(e));
            document.getElementById('messageInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); window.sendMessage(); }
            });
            usernameInputEl.addEventListener('input', (e) => { 
                localUsername = e.target.value.trim();
                localStorage.setItem('canvasChatUsername_v9_auth', localUsername);
                joinUsernameInputEl.value = localUsername; 
            });
             joinUsernameInputEl.addEventListener('input', (e) => {
                localUsername = e.target.value.trim();
                localStorage.setItem('canvasChatUsername_v9_auth', localUsername);
                usernameInputEl.value = localUsername; 
            });
        }
        
        function startListeningToPublicRooms() {
            if (!firebaseUser) { console.log("Cannot listen to rooms: not authenticated."); return; }
            console.log("Starting to listen to public rooms.");
            
            if (roomsListListenerUnsubscribe) roomsListListenerUnsubscribe(); // Detach old listener

            const roomsQuery = query(ref(db, 'rooms'), orderByChild('metadata/isPrivate'), equalTo(false));
            roomsListListenerUnsubscribe = onValue(roomsQuery, snapshot => {
                const roomsData = snapshot.val() || {};
                console.log("Public rooms data received:", roomsData);
                renderRoomsList(roomsData);
            }, error => {
                console.error("Error fetching public rooms:", error);
                if (error.code === 'PERMISSION_DENIED') {
                    addSystemMessageToChat('Error: Cannot access rooms list. Check Firebase rules.');
                } else { addSystemMessageToChat('Error fetching rooms list.'); }
            });
        }

        function renderRoomsList(roomsData) {
            const roomListEl = document.getElementById('roomList');
            roomListEl.innerHTML = ''; 
            const roomIds = Object.keys(roomsData);
            if (roomIds.length === 0) {
                roomListEl.innerHTML = '<p style="color: rgba(255,255,255,0.5); font-style:italic;">No active public rooms.</p>';
                return;
            }
            roomIds.forEach(roomId => {
                const room = roomsData[roomId];
                if (!room.metadata) return; 
                const roomDiv = document.createElement('div');
                roomDiv.className = 'room-item';
                if (roomId === currentRoomId) roomDiv.classList.add('active');
                const userCount = room.users ? Object.keys(room.users).length : 0;
                roomDiv.innerHTML = `<div class="room-name">${room.metadata.name}</div><div class="room-info">${userCount} user(s) online</div>`;
                roomDiv.addEventListener('click', () => {
                    if (!firebaseUser) { alert("Please wait for authentication to complete."); return; }
                    if (currentRoomId !== roomId) {
                        console.log(`Attempting to join room: ${roomId}`);
                        promptUserToJoinRoom(roomId, room.metadata);
                    }
                });
                roomListEl.appendChild(roomDiv);
            });
        }
        
        window.createRoom = function() { 
            console.log("createRoom function called.");
            if (!firebaseUser) { alert("Authentication required to create a room."); return; }
            if (!localUsername.trim()) { 
                alert("Please set your username before creating a room.");
                usernameInputEl.focus();
                return;
            }

            const roomName = roomNameInputEl.value.trim();
            const isPrivate = isPrivateCheckboxEl.checked;
            if (!roomName) { alert('Please enter a room name.'); return; }
            
            console.log(`Creating room: ${roomName}, Private: ${isPrivate}, User: ${localUsername}`);

            let password = null;
            if (isPrivate) {
                password = prompt('Enter room password (min 6 chars):');
                if (!password || password.length < 6) { alert('Private rooms require a password of at least 6 characters.'); return; }
            }
            
            if (currentRoomId) detachListenersAndLeaveCurrentRoom(); // Leave current if in one

            const newRoomRef = push(ref(db, 'rooms'));
            const newRoomId = newRoomRef.key;
            console.log("New Room ID generated by Firebase:", newRoomId);

            const roomMetadata = {
                name: roomName, isPrivate: isPrivate, creatorUsername: localUsername,
                creatorId: firebaseUser.uid, createdAt: serverTimestamp()
            };
            if (isPrivate) roomMetadata.passwordHash = password; // SUPER INSECURE, FOR DEMO ONLY
            
            const initialCanvasState = canvas.toDataURL();

            set(newRoomRef, { metadata: roomMetadata, fullCanvasDataUrl: initialCanvasState, users: {}, chatMessages: {} })
                .then(() => {
                    console.log(`Room "${roomName}" created successfully in Firebase.`);
                    addSystemMessageToChat(`Room "${roomName}" created.`);
                    performJoinRoomLogic(newRoomId, roomMetadata); // Join the room you just created
                }).catch(error => {
                    console.error("Error creating room in Firebase:", error);
                    alert("Error creating room: " + error.message + ". Check Firebase rules and console logs for PERMISSION_DENIED errors.");
                });
        }

        let selectedRoomIdToJoin = null; // Temporary store for modal
        let selectedRoomMetadataToJoin = null;

        function promptUserToJoinRoom(roomId, roomMetadata) {
            if (!firebaseUser) { alert("Authentication required."); return; }
            if (!localUsername.trim()) { 
                alert("Please set your username before joining a room.");
                usernameInputEl.focus();
                return;
            }
            selectedRoomIdToJoin = roomId; selectedRoomMetadataToJoin = roomMetadata;
            joinModalTitleEl.textContent = `Join Room: ${roomMetadata.name}`;
            joinUsernameInputEl.value = localUsername; // Pre-fill username
            joinPasswordGroupEl.style.display = roomMetadata.isPrivate ? 'block' : 'none';
            joinRoomPasswordInputEl.value = '';
            document.getElementById('joinModal').classList.remove('hidden');
        }
        
        window.confirmJoinRoom = function() { 
            if (!firebaseUser) { alert("Authentication required."); return; }
            const passwordAttempt = joinRoomPasswordInputEl.value;
            const usernameForJoin = joinUsernameInputEl.value.trim(); 
             if (!usernameForJoin) { alert("Please enter your username."); return; }
            localUsername = usernameForJoin; // Update local username from modal
            localStorage.setItem('canvasChatUsername_v9_auth', localUsername);

            if (selectedRoomMetadataToJoin.isPrivate) {
                // INSECURE password check - for demo only
                onValue(ref(db, `rooms/${selectedRoomIdToJoin}/metadata/passwordHash`), (snapshot) => {
                    const correctPasswordHash = snapshot.val();
                    if (passwordAttempt !== correctPasswordHash) { alert('Incorrect password.'); return; }
                    if (currentRoomId) detachListenersAndLeaveCurrentRoom();
                    performJoinRoomLogic(selectedRoomIdToJoin, selectedRoomMetadataToJoin);
                }, { onlyOnce: true }); 
            } else {
                if (currentRoomId) detachListenersAndLeaveCurrentRoom();
                performJoinRoomLogic(selectedRoomIdToJoin, selectedRoomMetadataToJoin);
            }
        }

        function performJoinRoomLogic(roomId, roomMeta) {
            if (!firebaseUser) { console.error("Cannot join room: not authenticated."); return; }
            console.log(`Performing join logic for room ${roomId}, user ${localUsername} (UID: ${firebaseUser.uid})`);
            currentRoomId = roomId; currentRoomData = roomMeta; 
            
            const userPresenceRef = ref(db, `rooms/${currentRoomId}/users/${firebaseUser.uid}`);
            set(userPresenceRef, localUsername).then(() => { // Add user to room's user list
                console.log(`User ${localUsername} added to room ${roomId} users list.`);
                const disconnectHandler = onDisconnect(userPresenceRef);
                disconnectHandler.remove(); // Set up onDisconnect to remove user
                
                currentRoomTitleEl.textContent = currentRoomData.name;
                closeModal();
                if (sidebarEl.classList.contains('open') && window.innerWidth <= 768) window.toggleSidebar();
                addSystemMessageToChat(`You joined "${currentRoomData.name}".`);
                
                document.querySelectorAll('.room-item.active').forEach(el => el.classList.remove('active'));
                const roomItemInList = Array.from(document.getElementById('roomList').children).find(child => child.textContent.includes(currentRoomData.name));
                if (roomItemInList) roomItemInList.classList.add('active');
                
                startListeningToCurrentRoomChanges();
            }).catch(error => {
                console.error("Error joining room (setting user presence):", error);
                alert("Failed to join room. Check Firebase rules (especially for writing to /users path) and console. Error: " + error.message);
                currentRoomId = null; currentRoomData = null; // Reset state
            });
        }
        
        function detachListenersAndLeaveCurrentRoom() {
            if (!currentRoomId || !firebaseUser) return;
            console.log(`Leaving room ${currentRoomId}`);
            addSystemMessageToChat(`You left "${currentRoomTitleEl.textContent}".`);

            // Detach all listeners for the current room
            if (roomUsersListenerUnsubscribe) roomUsersListenerUnsubscribe();
            if (roomChatListenerUnsubscribe) roomChatListenerUnsubscribe();
            if (roomCanvasListenerUnsubscribe) roomCanvasListenerUnsubscribe();
            roomUsersListenerUnsubscribe = roomChatListenerUnsubscribe = roomCanvasListenerUnsubscribe = null;

            const userPresenceRef = ref(db, `rooms/${currentRoomId}/users/${firebaseUser.uid}`);
            const disconnectHandler = onDisconnect(userPresenceRef);
            disconnectHandler.cancel(); // Cancel the onDisconnect handler since we're leaving gracefully
            remove(userPresenceRef); // Remove user from Firebase

            currentRoomId = null; currentRoomData = null;
            currentRoomTitleEl.textContent = 'Canvas Area';
            document.getElementById('usersList').innerHTML = '';
            document.getElementById('chatMessages').innerHTML = ''; 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveCanvasState(); // Reset local undo stack for the cleared canvas
            renderRoomsList({}); // Force re-render of room list (will be repopulated by listener)
            if (firebaseUser) startListeningToPublicRooms(); // Re-listen to public rooms
        }

        function startListeningToCurrentRoomChanges() {
            if (!currentRoomId || !firebaseUser) { console.log("Cannot listen to room changes: no current room or not authenticated."); return;}
            console.log(`Starting to listen to changes in room ${currentRoomId}`);

            // 1. Listen for users in the current room
            const usersRefPath = `rooms/${currentRoomId}/users`;
            if (roomUsersListenerUnsubscribe) roomUsersListenerUnsubscribe();
            roomUsersListenerUnsubscribe = onValue(ref(db, usersRefPath), snapshot => {
                const users = snapshot.val() || {};
                console.log("Room users update:", users);
                renderUsersList(Object.values(users));
                // Optional: update user count in public room list if this room's metadata is public
                 if (currentRoomData && !currentRoomData.isPrivate) {
                    if (firebaseUser) startListeningToPublicRooms(); // This will refresh the public list including user counts
                 }
            });

            // 2. Listen for chat messages in the current room
            const chatQuery = query(ref(db, `rooms/${currentRoomId}/chatMessages`), orderByChild('timestamp'), limitToLast(50));
            if (roomChatListenerUnsubscribe) roomChatListenerUnsubscribe();
            roomChatListenerUnsubscribe = onValue(chatQuery, snapshot => { 
                document.getElementById('chatMessages').innerHTML = ''; // Clear before re-rendering all
                snapshot.forEach(childSnapshot => {
                    const msg = childSnapshot.val();
                    if (msg) renderChatMessage(msg.username, msg.message, msg.userId === firebaseUser.uid);
                });
            });

            // 3. Listen for full canvas state of the current room
            const canvasStateRefPath = `rooms/${currentRoomId}/fullCanvasDataUrl`;
            if (roomCanvasListenerUnsubscribe) roomCanvasListenerUnsubscribe();
            roomCanvasListenerUnsubscribe = onValue(ref(db, canvasStateRefPath), snapshot => {
                const imageDataUrl = snapshot.val();
                console.log("Canvas state update received for room " + currentRoomId);
                if (imageDataUrl) {
                    loadCanvasFromDataUrl(imageDataUrl);
                } else { // If canvas data is null (e.g. new room before first draw)
                    ctx.clearRect(0,0,canvas.width, canvas.height);
                    saveCanvasState(); // Save empty state locally
                }
            });
        }

        function renderUsersList(usersArray) {
            const usersListEl = document.getElementById('usersList');
            usersListEl.innerHTML = usersArray.map(user => 
                `<span class="user-item ${user === localUsername ? 'me' : ''}">${user}</span>`
            ).join('');
        }

        function renderChatMessage(author, message, isOwnMessage = false) {
            const chatMessagesEl = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            if (isOwnMessage) messageDiv.classList.add('own-message');
            const authorSpan = document.createElement('span');
            authorSpan.className = 'message-author';
            authorSpan.textContent = author === localUsername && isOwnMessage ? 'You' : author;
            const textSpan = document.createElement('span');
            textSpan.className = 'message-text';
            textSpan.textContent = message; 
            messageDiv.appendChild(authorSpan); messageDiv.appendChild(textSpan);
            chatMessagesEl.appendChild(messageDiv);
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }
        function addSystemMessageToChat(message) {
            renderChatMessage('System', message, false);
        }


        window.sendMessage = function() { 
            if (!firebaseUser) { alert("Authentication required to send messages."); return; }
            if (!currentRoomId) { addSystemMessageToChat('You must be in a room to send messages.'); return; }
            if (!localUsername.trim()) { addSystemMessageToChat('Please set your username to send messages.'); return; }
            
            const inputEl = document.getElementById('messageInput');
            const messageText = inputEl.value.trim();
            if (messageText) {
                push(ref(db, `rooms/${currentRoomId}/chatMessages`), {
                    username: localUsername, userId: firebaseUser.uid, 
                    message: messageText, timestamp: serverTimestamp()
                }).then(() => inputEl.value = '')
                  .catch(e => {
                    console.error("Send message error:", e);
                    alert("Error sending message: " + e.message);
                  });
            }
        }

        // --- Canvas Drawing Logic ---
        function getMousePos(e) { 
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
            const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return [(clientX - rect.left) * scaleX, (clientY - rect.top) * scaleY];
        }

        function startDrawing(e) {
            if (!currentRoomId || !firebaseUser) return;
            e.preventDefault(); isDrawing = true;
            [lastX, lastY] = getMousePos(e);
            // currentPath removed as we sync full canvas
            if (currentTool === 'fill') {
                performFloodFill(Math.floor(lastX), Math.floor(lastY)); 
                saveCanvasState(); // Local undo
                syncCanvasStateToFirebase(); 
                isDrawing = false; return;
            }
            if (currentTool === 'brush' || currentTool === 'eraser') { // Draw a dot for single click
                const size = parseFloat(document.getElementById('brushSize').value);
                ctx.beginPath(); ctx.arc(lastX, lastY, size / 2, 0, Math.PI * 2);
                ctx.fillStyle = currentTool === 'brush' ? document.getElementById('colorPicker').value : 'rgba(0,0,0,0)'; // Eraser needs transparency
                if (currentTool === 'eraser') ctx.globalCompositeOperation = 'destination-out';
                else ctx.globalCompositeOperation = 'source-over';
                ctx.fill(); ctx.globalCompositeOperation = 'source-over'; 
            }
        }

        function draw(e) {
            if (!isDrawing || !currentRoomId || !firebaseUser) return;
            e.preventDefault();
            const [currentX, currentY] = getMousePos(e);
            const color = document.getElementById('colorPicker').value;
            const size = parseFloat(document.getElementById('brushSize').value);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; 
            if (currentTool === 'brush') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = color; ctx.lineWidth = size;
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out'; 
                ctx.lineWidth = size;
            } else return;
            ctx.beginPath(); ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY); ctx.stroke();
            [lastX, lastY] = [currentX, currentY];
        }

        function stopDrawing(e) {
            // Only update Firebase if drawing actually happened or it was a fill operation
            if ((!isDrawing && currentTool !== 'fill') || !currentRoomId || !firebaseUser) {
                isDrawing = false; // Ensure isDrawing is reset
                return;
            }
            isDrawing = false; 
            if (e) e.preventDefault();
            ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
            saveCanvasState(); // Save local state for undo/redo
            syncCanvasStateToFirebase(); 
        }
        
        function syncCanvasStateToFirebase() {
            if (!currentRoomId || !firebaseUser) { console.log("Cannot sync canvas: no room or not authed."); return; }
            console.log("Syncing canvas state to Firebase for room:", currentRoomId);
            const imageDataUrl = canvas.toDataURL(); // Get current canvas state
            set(ref(db, `rooms/${currentRoomId}/fullCanvasDataUrl`), imageDataUrl)
                .catch(error => {
                    console.error("Error updating canvas state in Firebase:", error);
                    if (error.code === 'PERMISSION_DENIED') {
                        addSystemMessageToChat('Error: Canvas update denied. Check Firebase rules.');
                    }
                });
        }

        function performFloodFill(startX, startY) { 
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data; const startPos = (startY * canvas.width + startX) * 4;
            const startR = data[startPos], startG = data[startPos + 1], startB = data[startPos + 2];
            const fillColorHex = document.getElementById('colorPicker').value;
            const fillColorRgb = hexToRgb(fillColorHex); if (!fillColorRgb) return; 
            const [fillR, fillG, fillB] = fillColorRgb;
            if (startR === fillR && startG === fillG && startB === fillB) return; // Clicked on already filled area
            const q = [[startX, startY]]; // Use a queue for breadth-first
            while (q.length > 0) {
                const [x, y] = q.shift();
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                const currentPos = (y * canvas.width + x) * 4;
                if (data[currentPos] === startR && data[currentPos+1] === startG && data[currentPos+2] === startB) {
                    data[currentPos] = fillR; data[currentPos+1] = fillG; data[currentPos+2] = fillB; data[currentPos+3] = 255;
                    q.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }
        function hexToRgb(hex) { 
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
        }

        window.handleImageUpload = function(e) { 
            if (!currentRoomId || !firebaseUser) { alert("Please join a room and be authenticated to import images."); e.target.value = null; return; }
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const hRatio = canvas.width / img.width, vRatio = canvas.height / img.height;
                    const ratio = Math.min(hRatio, vRatio, 1); 
                    const centerX = (canvas.width - img.width * ratio) / 2, centerY = (canvas.height - img.height * ratio) / 2;
                    ctx.drawImage(img, 0, 0, img.width, img.height, centerX, centerY, img.width * ratio, img.height * ratio);
                    saveCanvasState(); syncCanvasStateToFirebase();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file); e.target.value = null; 
        }

        function saveCanvasState() { 
            if (undoStack.length >= 20) undoStack.shift(); 
            undoStack.push(canvas.toDataURL());
            redoStack = []; updateUndoRedoButtonsUI();
        }
        window.undo = function() { 
            if (!firebaseUser || !currentRoomId) return;
            if (undoStack.length > 1) { 
                redoStack.push(undoStack.pop());
                applyLocalCanvasStateForUndoRedo(undoStack[undoStack.length - 1]);
            }
        }
        window.redo = function() { 
            if (!firebaseUser || !currentRoomId) return;
            if (redoStack.length > 0) {
                const imageData = redoStack.pop();
                undoStack.push(imageData);
                applyLocalCanvasStateForUndoRedo(imageData);
            }
        }
        function applyLocalCanvasStateForUndoRedo(imageDataUrl) { 
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                ctx.drawImage(img, 0, 0);
                if(firebaseUser && currentRoomId) syncCanvasStateToFirebase(); // Sync this undone/redone state
                updateUndoRedoButtonsUI();
            };
            img.src = imageDataUrl;
        }
        function updateUndoRedoButtonsUI(){ 
            document.querySelector('.tool-btn[onclick="window.undo()"]').disabled = undoStack.length <= 1;
            document.querySelector('.tool-btn[onclick="window.redo()"]').disabled = redoStack.length === 0;
        }

        window.clearCanvas = function() { 
            if (!currentRoomId || !firebaseUser) { alert("Must be in a room and authenticated to clear canvas."); return; }
            if (confirm("Clear canvas for everyone in this room?")) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                saveCanvasState(); syncCanvasStateToFirebase();
            }
        }
        window.downloadCanvas = function() { 
            const link = document.createElement('a');
            link.download = `canvas-${currentRoomData ? currentRoomData.name.replace(/\s+/g, '_') : 'drawing'}.png`;
            link.href = canvas.toDataURL('image/png'); link.click();
        }

        function loadCanvasFromDataUrl(canvasDataUrl) { 
            console.log("Loading canvas from data URL (remote update)");
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0);
                // This is a remote update, so set it as the new base for local undo stack
                undoStack = [canvas.toDataURL()]; redoStack = [];
                updateUndoRedoButtonsUI();
            };
            img.onerror = () => { console.error("Error loading image from data URL for canvas.")}
            img.src = canvasDataUrl;
        }

        // --- UI & Mobile Helper Functions ---
        function setupMobileSupportUI() { 
            const isMobile = window.innerWidth <= 768;
            mainMobileMenuBtnEl.style.display = isMobile ? 'flex' : 'none';
            sidebarMobileMenuBtnEl.style.display = isMobile ? 'flex' : 'none';
            if (!isMobile) { sidebarEl.classList.remove('open'); appContainerEl.classList.remove('sidebar-open'); }
            if (isMobile && sidebarEl.classList.contains('open')) { window.toggleSidebar(); }
        }
        window.addEventListener('resize', setupMobileSupportUI);

        window.toggleSidebar = function() { 
            sidebarEl.classList.toggle('open'); appContainerEl.classList.toggle('sidebar-open');
            const sidebarIcon = sidebarMobileMenuBtnEl.querySelector('i');
            sidebarIcon.setAttribute('data-lucide', sidebarEl.classList.contains('open') ? 'x' : 'menu');
            lucide.createIcons(); 
        }
        window.closeModal = function() { 
            document.getElementById('joinModal').classList.add('hidden');
            joinRoomPasswordInputEl.value = '';
        }
        
        function setupCanvasInteractionEvents() { 
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing); // Stop drawing if mouse leaves canvas

            // Touch events for basic drawing
            canvas.addEventListener('touchstart', (e) => { 
                if (!firebaseUser || !currentRoomId) return; e.preventDefault();
                const touch = e.touches[0] || e.changedTouches[0];
                const mockEvent = new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY });
                startDrawing(mockEvent);
            }, { passive: false }); // passive:false to allow preventDefault
            canvas.addEventListener('touchmove', (e) => { 
                if (!isDrawing || !firebaseUser || !currentRoomId) return; e.preventDefault(); 
                const touch = e.touches[0] || e.changedTouches[0];
                const mockEvent = new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY });
                draw(mockEvent);
            }, { passive: false });
            canvas.addEventListener('touchend', (e) => { 
                if (!firebaseUser || !currentRoomId) return; e.preventDefault();
                const touch = e.changedTouches[0]; 
                 // If no touch object (e.g., mouseup simulated from touchend), use last known for safety
                const clientX = touch ? touch.clientX : lastX; 
                const clientY = touch ? touch.clientY : lastY;
                const mockEvent = new MouseEvent('mouseup', { clientX: clientX, clientY: clientY });
                stopDrawing(mockEvent);
            }, { passive: false });
        }
    </script>
</body>
</html>
